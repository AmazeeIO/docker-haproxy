{{ define "upstream" }}
        {{ if .Address }}
                {{/* If we got the containers from swarm and this container's port is published to host, use host IP:P$ */}}
                {{ if and .Container.Node.ID .Address.HostPort }}
                        # {{ .Container.Node.Name }}/{{ .Container.Name }}
                        server {{ .Container.Node.Address.IP }}:{{ .Address.HostPort }} {{ .Container.Node.Address.IP }}:{{ .Address.HostPort }} check
                {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
                {{ else if .Address.IP }}
                        # {{ .Container.Name }}
                        server {{ .Address.IP }}:{{ .Address.Port }} {{ .Address.IP }}:{{ .Address.Port }} check
                {{ else }}
                        # {{ .Container.Name }}
                        server {{ .Container.Name }}:{{ .Address.Port }} {{ .Container.Name }}:{{ .Address.Port }} check
                {{ end }}
        {{ end }}
{{ end }}

global
	daemon
	maxconn 1024
	pidfile /var/run/haproxy.pid

defaults
	balance roundrobin
	timeout client 60s
	timeout connect 60s
	timeout server 60s
	option http-server-close
	option forwardfor

	stats enable
	stats refresh 30s
	stats show-node
	stats uri  /stats

frontend http
	mode http
	bind :80
{{/* We are only interested in containers that have the environment variable AMAZEEIO set */}}
{{range $key, $container := whereExist $ "Env.AMAZEEIO" }}
	{{$host := $container.Name }}
	use_backend http_{{$host}} if { hdr_end(host) -i {{$host}} }
{{end}}

frontend https
	mode tcp
	bind *:443
	option socket-stats
	tcp-request inspect-delay 5s
	tcp-request content accept if { req_ssl_hello_type 1 }
{{range $key, $container := whereExist $ "Env.AMAZEEIO" }}
        {{$host := $container.Name }}
	use_backend https_{{$host}} if { req_ssl_sni -i {{$host}} }
{{end}}

{{range $key, $container := whereExist $ "Env.AMAZEEIO" }}
{{$host := $container.Name }}
backend http_{{$host}}
		mode http
		{{$addrLen := len $container.Addresses}}
		{{if eq $addrLen 1}}
			{{ $address := index $container.Addresses 0 }}
			{{ template "upstream" (dict "Container" $container "Address" $address) }}
		{{else}}
			{{ $address := where $container.Addresses "Port" "80" | first }}
			{{ template "upstream" (dict "Container" $container "Address" $address) }}
		{{end}}

backend https_{{$host}}
	#balance leastconn
	mode tcp

	# maximum SSL session ID length is 32 bytes.
	stick-table type binary len 32 size 30k expire 30m

	acl clienthello req_ssl_hello_type 1
	acl serverhello rep_ssl_hello_type 2

	# use tcp content accepts to detects ssl client and server hello.
	tcp-request inspect-delay 5s
	tcp-request content accept if clienthello

	# no timeout on response inspect delay by default.
	tcp-response content accept if serverhello

	stick on payload_lv(43,1) if clienthello

	# Learn on response if server hello.
	stick store-response payload_lv(43,1) if serverhello

	option ssl-hello-chk

	{{$addrLen := len $container.Addresses}}
	{{if eq $addrLen 1}}
		{{ $address := index $container.Addresses 0 }}
		{{ template "upstream" (dict "Container" $container "Address" $address) }}
	{{else}}
		{{ $address := where $container.Addresses "Port" "443" | first }}
		{{ template "upstream" (dict "Container" $container "Address" $address) }}
	{{end}}
{{end}}


